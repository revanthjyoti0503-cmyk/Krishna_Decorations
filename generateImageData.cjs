const fs = require('fs');
const path = require('path');

const imagesDir = path.join(__dirname, 'public', 'images');
const outputFile = path.join(__dirname, 'src', 'utils', 'imageData.ts');

function getImagesFromFolder(folder, category) {
  const files = fs.readdirSync(folder);
  return files
    .filter(file => /\.(jpe?g|png|webp|gif)$/i.test(file))
    .map(file => ({
      src: `/images/${category}/${file}`,
      alt: file.replace(/\.[^/.]+$/, ''),
      category,
      description: `${file} from ${category}`
    }));
}

const categories = fs
  .readdirSync(imagesDir)
  .filter(f => fs.statSync(path.join(imagesDir, f)).isDirectory());

let categoryBlocks = [];

for (const category of categories) {
  const folderPath = path.join(imagesDir, category);
  const images = getImagesFromFolder(folderPath, category);
  const varName = category.replace(/[^a-zA-Z0-9]/g, '');
  categoryBlocks.push(
    `export const ${varName}Images: ImageData[] = ${JSON.stringify(images, null, 2)};`
  );
}

const portfolioSpread = categories.map(c => `...${c.replace(/[^a-zA-Z0-9]/g, '')}Images`).join(',\n  ');

const firstOfEachCategory = categories
  .map(c => `${c.replace(/[^a-zA-Z0-9]/g, '')}Images[0]`)
  .join(',\n  ');

const fileContent = `// Auto-generated by generateImageData.js
export interface ImageData {
  src: string;
  alt: string;
  category: string;
  description?: string;
}

${categoryBlocks.join('\n\n')}

export const portfolioImages: ImageData[] = [
  ${portfolioSpread}
];

// Slideshow images (selecting best from each category)
export const slideshowImages: ImageData[] = [
  ${firstOfEachCategory}
].filter(Boolean);

// Exclude categories globally (e.g., remove "Baby shower" everywhere)
export const EXCLUDED_CATEGORIES = new Set<string>(['Baby shower']);

export const activePortfolioImages: ImageData[] = portfolioImages.filter(img => !EXCLUDED_CATEGORIES.has(img.category));
export const activeSlideshowImages: ImageData[] = slideshowImages.filter(img => !EXCLUDED_CATEGORIES.has(img.category));

// Fallback images for when local images are not available
export const fallbackImages: ImageData[] = [
  {
    src: 'https://images.pexels.com/photos/587741/pexels-photo-587741.jpeg?auto=compress&cs=tinysrgb&w=800&h=600&fit=crop',
    alt: 'Wedding Decoration',
    category: 'Wedding',
    description: 'Beautiful wedding decoration setup'
  },
  {
    src: 'https://images.pexels.com/photos/587741/pexels-photo-587741.jpeg?auto=compress&cs=tinysrgb&w=800&h=600&fit=crop',
    alt: 'Birthday Party',
    category: 'Birthday',
    description: 'Colorful birthday party decoration'
  },
  {
    src: 'https://images.pexels.com/photos/587741/pexels-photo-587741.jpeg?auto=compress&cs=tinysrgb&w=800&h=600&fit=crop',
    alt: 'Engagement Ceremony',
    category: 'Engagement',
    description: 'Elegant engagement ceremony setup'
  }
];

export const fallbackSlideshowImages: ImageData[] = [
  {
    src: 'https://images.pexels.com/photos/587741/pexels-photo-587741.jpeg?auto=compress&cs=tinysrgb&w=1200&h=600&fit=crop',
    alt: 'Wedding Decoration',
    category: 'Wedding',
    description: 'Stunning wedding decoration with traditional elements and modern aesthetics'
  },
  {
    src: 'https://images.pexels.com/photos/587741/pexels-photo-587741.jpeg?auto=compress&cs=tinysrgb&w=1200&h=600&fit=crop',
    alt: 'Birthday Celebration',
    category: 'Birthday',
    description: 'Vibrant birthday party decoration with balloons and colorful themes'
  },
  {
    src: 'https://images.pexels.com/photos/587741/pexels-photo-587741.jpeg?auto=compress&cs=tinysrgb&w=1200&h=600&fit=crop',
    alt: 'Engagement Setup',
    category: 'Engagement',
    description: 'Elegant engagement ceremony decoration with floral arrangements'
  }
];

// Get all unique categories
export const getAllCategories = (): string[] => {
  const categories = new Set(activePortfolioImages.map(img => img.category));
  return Array.from(categories).sort();
};

// Get categories sorted by image count (most images first)
export const getCategoriesByCount = () => {
  const categoryCounts = activePortfolioImages.reduce((acc, img) => {
    acc[img.category] = (acc[img.category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  return Object.entries(categoryCounts)
    .map(([category, count]) => ({ category, count }))
    .sort((a, b) => b.count - a.count); // Sort by count descending
};
`;

fs.writeFileSync(outputFile, fileContent, 'utf8');
console.log('imageData.ts has been generated!'); 